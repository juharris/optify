import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as yaml from 'js-yaml';
import { GetOptionsPreferences, OptionsProvider } from '@optify/config';

// This file was mostly generated by Claude Code.
// Justin did review it and improved some parts, but didn't check the logic in detail for file parsing.

export function activate(context: vscode.ExtensionContext) {
	console.debug('Optify extension is now active!');

	// Set up context for when clauses
	updateOptifyFileContext();

	const previewCommand = vscode.commands.registerCommand('optify.previewFeature', async () => {
		const activeEditor = vscode.window.activeTextEditor;
		if (!activeEditor) {
			vscode.window.showErrorMessage('No active editor found');
			return;
		}

		const document = activeEditor.document;
		const filePath = document.fileName;

		console.debug(`Previewing feature file: ${filePath}`);
		if (!isOptifyFeatureFile(filePath)) {
			vscode.window.showErrorMessage('Current file is not an Optify feature file');
			return;
		}

		try {
			const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);
			if (!workspaceFolder) {
				vscode.window.showErrorMessage('File must be in a workspace');
				return;
			}

			const optifyRoot = findOptifyRoot(filePath, workspaceFolder.uri.fsPath);
			if (!optifyRoot) {
				vscode.window.showErrorMessage('Could not find Optify root directory');
				return;
			}

			const canonicalName = getCanonicalName(filePath, optifyRoot);

			const provider = OptionsProvider.build(optifyRoot);
			const preferences = new GetOptionsPreferences();
			preferences.setSkipFeatureNameConversion(true);
			const builtConfigJson = provider.getAllOptionsJson([canonicalName], preferences);
			const builtConfig = JSON.parse(builtConfigJson);

			const panel = vscode.window.createWebviewPanel(
				'optifyPreview',
				`Optify Preview: ${canonicalName}`,
				vscode.ViewColumn.Beside,
				{ enableScripts: false }
			);

			panel.webview.html = getPreviewHtml([canonicalName], builtConfig);
		} catch (error) {
			console.error('Optify build error:', error);
			vscode.window.showErrorMessage(`Failed to build feature: ${error}`);
		}
	});

	const documentLinkProvider = new OptifyDocumentLinkProvider();
	const linkProvider = vscode.languages.registerDocumentLinkProvider(
		[{ scheme: 'file' }],
		documentLinkProvider
	);

	const diagnosticCollection = vscode.languages.createDiagnosticCollection('optify');
	const diagnosticsProvider = new OptifyDiagnosticsProvider(diagnosticCollection);

	const onDidChangeDocument = vscode.workspace.onDidChangeTextDocument((event) => {
		if (isOptifyFeatureFile(event.document.fileName)) {
			diagnosticsProvider.updateDiagnostics(event.document);
		}
	});

	const onDidOpenDocument = vscode.workspace.onDidOpenTextDocument((document) => {
		if (isOptifyFeatureFile(document.fileName)) {
			diagnosticsProvider.updateDiagnostics(document);
		}
		updateOptifyFileContext();
	});

	const onDidChangeActiveEditor = vscode.window.onDidChangeActiveTextEditor(() => {
		updateOptifyFileContext();
	});

	context.subscriptions.push(
		previewCommand,
		linkProvider,
		diagnosticCollection,
		onDidChangeDocument,
		onDidOpenDocument,
		onDidChangeActiveEditor
	);
}

function updateOptifyFileContext() {
	const activeEditor = vscode.window.activeTextEditor;
	const isOptifyFile = activeEditor ? isOptifyFeatureFile(activeEditor.document.fileName) : false;
	vscode.commands.executeCommand('setContext', 'optify.isOptifyFile', isOptifyFile);
}

function isOptifyFeatureFile(filePath: string, optifyRoot: string | undefined = undefined): boolean {
	const ext = path.extname(filePath).toLowerCase();
	// We only support a few types of files in this extension and the config Rust crate only supports a few file types.
	if (!['.json', '.yaml', '.yml', '.json5'].includes(ext)) {
		return false;
	}

	// Check if file is in an Optify project by looking for root directory
	const workspaceFolder = vscode.workspace.getWorkspaceFolder(vscode.Uri.file(filePath));
	if (!workspaceFolder) {
		return false;
	}

	optifyRoot ||= findOptifyRoot(filePath, workspaceFolder.uri.fsPath);
	return optifyRoot !== undefined;
}

function findOptifyRoot(filePath: string, workspaceRoot: string): string | undefined {
	let currentDir = path.dirname(filePath);

	const configDirs = ['options', 'configs', 'configurations'];
	while (currentDir !== path.dirname(currentDir)) {
		// Check for configuration directories
		const currentDirName = path.basename(currentDir);
		if (configDirs.includes(currentDirName)) {
			return currentDir;
		}

		// Look for some kind of marker file, but it shouldn't be a suffix for a feature file.
		const optifyConfigPath = path.join(currentDir, '.optify');
		if (fs.existsSync(optifyConfigPath)) {
			return currentDir;
		}

		currentDir = path.dirname(currentDir);
		if (currentDir === workspaceRoot) {
			return undefined;
		}
	}

	return undefined;
}

function getCanonicalName(filePath: string, optifyRoot: string): string {
	const relativePath = path.relative(optifyRoot, filePath);
	const result = path.join(path.dirname(relativePath), path.basename(relativePath, path.extname(relativePath)));

	return result;
}

function getPreviewHtml(features: string[], config: any): string {
	const configJson = JSON.stringify(config, null, 2);
	const featuresString = JSON.stringify(features);
	return `
		<!DOCTYPE html>
		<html>
		<head>
			<title>Optify Preview: ${featuresString}</title>
			<style>
				body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; }
				h2 { border-bottom: 2px solid #007acc; padding-bottom: 10px; }
				pre { padding: 1rem; overflow-x: auto; background-color: #383838; color: #d8d8d8; border-radius: 4px; }
				code { background-color: transparent; font-family: 'Courier New', Courier, monospace; }
			</style>
		</head>
		<body>
			<h2>Features: <code>${featuresString}</code></h1>
			<pre><code>${configJson}</code></pre>
		</body>
		</html>
	`;
}

/**
 * Shared utility functions for parsing configuration files
 */
class ConfigParser {
	static findImportRange(text: string, importName: string, index: number, languageId: string): vscode.Range | undefined {
		switch (languageId) {
			case 'json':
				return ConfigParser.findImportRangeInJson(text, importName, index);
			case 'yaml':
				return ConfigParser.findImportRangeInYaml(text, importName, index);
			default:
				return undefined;
		}
	}

	static parseImports(text: string, languageId: string): string[] | null {
		switch (languageId) {
			case 'json':
				return this.parseJsonImports(text);
			case 'yaml':
				return this.parseYamlImports(text);
			default:
				return null;
		}
	}

	static parseJsonImports(text: string): string[] | null {
		try {
			const config = JSON.parse(text);
			if (config.imports && Array.isArray(config.imports)) {
				return config.imports.filter((imp: any) => typeof imp === 'string');
			}
		} catch (error) {
			// Ignore JSON parse errors
		}
		return null;
	}

	static parseYamlImports(text: string): string[] | null {
		try {
			const config = yaml.load(text) as any;
			if (config && config.imports && Array.isArray(config.imports)) {
				return config.imports.filter((imp: any) => typeof imp === 'string');
			}
		} catch (error) {
			// Ignore YAML parse errors
		}
		return null;
	}

	static findImportRangeInJson(text: string, importName: string, index: number): vscode.Range | undefined {
		try {
			const config = JSON.parse(text);
			if (!config.imports || !Array.isArray(config.imports)) {
				return undefined;
			}

			// Check if the import at the given index matches the importName
			if (index >= config.imports.length || config.imports[index] !== importName) {
				return undefined;
			}

			// Now find this specific occurrence in the text by position
			return this.findImportAtIndexInJsonText(text, index);
		} catch (error) {
			// If JSON parsing fails, fall back to regex approach
		}
		return undefined;
	}

	private static findImportAtIndexInJsonText(text: string, index: number): vscode.Range | undefined {
		const importsMatch = text.match(/"imports"\s*:\s*\[([^\]]*)\]/s);
		if (!importsMatch) {
			return undefined;
		}

		const importsContent = importsMatch[1];
		const importsArrayStartIndex = importsMatch.index! + importsMatch[0].indexOf(importsMatch[1]);

		// Find all string literals in the imports array
		const stringLiteralPattern = /"([^"]*)"/g;
		const matches: RegExpExecArray[] = [];
		let match;

		while ((match = stringLiteralPattern.exec(importsContent)) !== null) {
			matches.push(match);
		}

		if (index < matches.length) {
			const targetMatch = matches[index];
			const importName = targetMatch[1];
			// Calculate position relative to the start of the imports array content
			const startPos = importsArrayStartIndex + targetMatch.index! + 1; // +1 to skip the opening quote
			const endPos = startPos + importName.length;

			const startPosition = this.getPositionFromIndex(text, startPos);
			const endPosition = this.getPositionFromIndex(text, endPos);

			return new vscode.Range(startPosition, endPosition);
		}

		return undefined;
	}

	static findImportRangeInYaml(text: string, importName: string, index: number): vscode.Range | undefined {
		const lines = text.split('\n');
		let inImportsSection = false;
		let currentIndex = 0;
		let importLineIndex = -1;

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];
			const trimmedLine = line.trim();

			// Check if we're entering the imports section
			if (trimmedLine === 'imports:' || trimmedLine.startsWith('imports:')) {
				inImportsSection = true;
				continue;
			}

			// If we're in imports section and hit another top-level key, exit
			if (inImportsSection && trimmedLine && !trimmedLine.startsWith('-') && !trimmedLine.startsWith(' ') && trimmedLine.includes(':')) {
				break;
			}

			// Look for import items
			if (inImportsSection && (trimmedLine.startsWith('- ') || trimmedLine.startsWith('-'))) {
				const importMatch = trimmedLine.match(/^-\s*["']?([^"'\n]+?)["']?\s*$/);
				if (importMatch) {
					const extractedImport = importMatch[1].trim();
					if (extractedImport === importName && currentIndex === index) {
						importLineIndex = i;
						break;
					}
					currentIndex++;
				}
			}
		}

		if (importLineIndex >= 0) {
			const line = lines[importLineIndex];
			const startCol = line.indexOf(importName);
			if (startCol >= 0) {
				const startPos = new vscode.Position(importLineIndex, startCol);
				const endPos = new vscode.Position(importLineIndex, startCol + importName.length);
				return new vscode.Range(startPos, endPos);
			}
		}

		return undefined;
	}

	static getPositionFromIndex(text: string, index: number): vscode.Position {
		const lines = text.substring(0, index).split('\n');
		return new vscode.Position(lines.length - 1, lines[lines.length - 1].length);
	}
}

/**
 * Adds links to imports.
 */
class OptifyDocumentLinkProvider implements vscode.DocumentLinkProvider {
	provideDocumentLinks(document: vscode.TextDocument): vscode.DocumentLink[] {
		const links: vscode.DocumentLink[] = [];
		const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);
		if (!workspaceFolder) {
			return links; // No workspace folder, no links
		}

		const optifyRoot = findOptifyRoot(document.uri.fsPath, workspaceFolder.uri.fsPath);

		// Only provide links for Optify feature files
		if (!optifyRoot || !isOptifyFeatureFile(document.fileName, optifyRoot)) {
			return links;
		}

		console.debug(`Providing document links for ${document.fileName} | languageId: ${document.languageId}`);
		const text = document.getText();

		const imports = ConfigParser.parseImports(text, document.languageId);
		if (imports) {
			for (let i = 0; i < imports.length; i++) {
				const importName = imports[i];
				const range = ConfigParser.findImportRange(text, importName, i, document.languageId);
				if (range) {
					const targetPath = this.resolveImportPath(importName, optifyRoot);
					if (targetPath) {
						const link = new vscode.DocumentLink(range, vscode.Uri.file(targetPath));
						links.push(link);
					}
				}
			}
		}

		return links;
	}

	private resolveImportPath(importName: string, optifyRoot: string): string | undefined {
		const extensions = ['.json', '.yaml', '.yml', '.json5'];

		// Try resolving relative to the optify root
		for (const ext of extensions) {
			const possiblePath = path.resolve(optifyRoot, importName + ext);
			if (fs.existsSync(possiblePath)) {
				return possiblePath;
			}
		}

		return undefined;
	}
}

/**
 * Validates files such as validating imports.
 */
class OptifyDiagnosticsProvider {
	constructor(private diagnosticCollection: vscode.DiagnosticCollection) { }

	updateDiagnostics(document: vscode.TextDocument): void {
		console.debug(`Updating diagnostics for ${document.fileName} | languageId: ${document.languageId}`);
		const diagnostics: vscode.Diagnostic[] = [];
		const text = document.getText();

		const workspaceFolder = vscode.workspace.getWorkspaceFolder(document.uri);
		if (!workspaceFolder) {
			return;
		}

		const imports = ConfigParser.parseImports(text, document.languageId);
		if (imports) {
			for (let i = 0; i < imports.length; i++) {
				const importName = imports[i];
				const targetPath = this.resolveImportPath(importName, document.uri.fsPath, workspaceFolder.uri.fsPath);
				if (!targetPath) {
					const range = ConfigParser.findImportRange(text, importName, i, document.languageId);
					if (range) {
						const diagnostic = new vscode.Diagnostic(
							range,
							`Cannot resolve import '${importName}'`,
							vscode.DiagnosticSeverity.Error
						);
						diagnostics.push(diagnostic);
					}
				}
			}
		}

		this.diagnosticCollection.set(document.uri, diagnostics);
	}

	private resolveImportPath(importName: string, currentFilePath: string, workspaceRoot: string): string | undefined {
		const optifyRoot = findOptifyRoot(currentFilePath, workspaceRoot);
		if (!optifyRoot) {
			return undefined;
		}

		const extensions = ['.json', '.yaml', '.yml', '.json5'];

		// Try resolving relative to the optify root
		for (const ext of extensions) {
			const possiblePath = path.resolve(optifyRoot, importName + ext);
			if (fs.existsSync(possiblePath)) {
				return possiblePath;
			}
		}

		return undefined;
	}
}

export function deactivate() { }
